package state

import (
	"encoding/json"
	"fmt"
    "strings"

	"github.com/ocuroot/ui/components"
    "github.com/ocuroot/ui/components/layout"
    "github.com/ocuroot/ocuroot/store/models"
    "github.com/ocuroot/ocuroot/lib/release"
    "github.com/ocuroot/ocuroot/sdk"
    "github.com/ocuroot/ocuroot/refs"
    "github.com/gobwas/glob"
)

type RefPageProps struct {
    Ref string
    ResolvedRef string

    Content any
    ChildRefs []string
}

templ HeaderLink(ref string, glob glob.Glob, text string, url string) {
    <div class="headeritem">
        if !glob.Match(ref) {
            <a href={ templ.SafeURL(url) }>{ text }</a>
        } else {
            <h1>{ text }</h1>
        }
    </div>
}

templ RefHeader(props RefPageProps) {
    <div class="ref-header">
    if rp, err := refs.Parse(props.Ref); err == nil {
        if rp.Repo != "" {
            @HeaderLink(
                props.Ref, 
                release.GlobRepoConfig, 
                rp.Repo, 
                fmt.Sprintf("/match/%s/-/**/@*", rp.Repo),
            )
        } 
        if rp.Filename != "" {
            @HeaderLink(
                props.Ref, 
                release.GlobPackage, 
                rp.Filename, 
                fmt.Sprintf("/match/%s/-/%s/@*", rp.Repo, rp.Filename),
            )
        }
        if rp.ReleaseOrIntent.Value != "" {
            @HeaderLink(
                props.Ref, 
                release.GlobRelease, 
                fmt.Sprintf("Release %s", rp.ReleaseOrIntent.Value), 
                fmt.Sprintf("/ref/%s/-/%s/@%s", rp.Repo, rp.Filename, rp.ReleaseOrIntent.Value),
            )
        }
        if rp.SubPathType == refs.SubPathTypeCall {
            @HeaderLink(
                props.Ref, 
                release.GlobCall, 
                fmt.Sprintf("Call '%s'", strings.Split(rp.SubPath, "/")[0]), 
                fmt.Sprintf("/ref/%s/-/%s/@%s/call/%s", rp.Repo, rp.Filename, rp.ReleaseOrIntent.Value, strings.Split(rp.SubPath, "/")[0]),
            )
            if len(strings.Split(rp.SubPath, "/")) > 1 {
                @HeaderLink(
                    props.Ref, 
                    release.GlobChain, 
                    fmt.Sprintf("#%s", strings.Split(rp.SubPath, "/")[1]), 
                    fmt.Sprintf("/ref/%s/-/%s/@%s/call/%s/%s", rp.Repo, rp.Filename, rp.ReleaseOrIntent.Value, strings.Split(rp.SubPath, "/")[0], strings.Split(rp.SubPath, "/")[1]),
                )
            }
        }
        if rp.SubPathType == refs.SubPathTypeDeploy {
            @HeaderLink(
                props.Ref, 
                release.GlobDeploymentState, 
                fmt.Sprintf("Deploy to %s", strings.Split(rp.SubPath, "/")[0]), 
                fmt.Sprintf("/ref/%s/-/%s/@%s/deploy/%s", rp.Repo, rp.Filename, rp.ReleaseOrIntent.Value, rp.SubPath),
            )
            if len(strings.Split(rp.SubPath, "/")) > 1 {
                @HeaderLink(
                    props.Ref, 
                    release.GlobChain, 
                    fmt.Sprintf("#%s", strings.Split(rp.SubPath, "/")[1]), 
                    fmt.Sprintf("/ref/%s/-/%s/@%s/deploy/%s/%s", rp.Repo, rp.Filename, rp.ReleaseOrIntent.Value, strings.Split(rp.SubPath, "/")[0], strings.Split(rp.SubPath, "/")[1]),
                )
            }
        }
        if rp.SubPathType == refs.SubPathTypeEnvironment {
            <a href={ fmt.Sprintf("/match/%s", GlobEnvironments) }>Environments</a>
            <h1>{ rp.SubPath }</h1>
        }
        if rp.SubPathType == refs.SubPathTypeCustom {
            if rp.Repo != "" {
                <h1>Custom: '{rp.SubPath}'</h1>
            } else {
                <a href={ fmt.Sprintf("/match/%s", GlobCustomState) }>Custom state</a>
                <h1>{ rp.SubPath }</h1>
            }
        }
    } else if err != nil {
        <p>Invalid ref: { props.ResolvedRef }</p>
        <p>{ err.Error() }</p>
    }
    </div>
}

templ RefPage(props RefPageProps) {
	@ViewBody(){
        if props.Content != nil {
            @StateContentWithHeader(props)
        } else {
            <h2>Refs</h2>
            @RefList(props.ResolvedRef, BuildRefTree(props.ChildRefs))
        }
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/default.min.css">        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/json.min.js"></script>
        <script>hljs.highlightAll();</script>
	}
}

templ StateContentWithHeader(props RefPageProps) {
    @RefHeader(props)
    @StateContent(props)
}

templ StateContent(props RefPageProps) {
    switch c := props.Content.(type) {
        case release.ReleaseInfo:
            @ReleaseCard(props)
        case models.Work:
            @WorkView(props)
        case models.Intent:
            @components.Card() {
                <pre><code class="language-json">{ toJson(c) }</code></pre>
            }
        case []sdk.Log:
            @Logs(c)
        case release.FunctionState:
            @FunctionState(props)
        case models.Environment:
            @Environment(props)
        default:
            @layout.Row() {
                @layout.Column() {
                    <h2>State</h2>
                    @components.Card() {
                        <pre><code class="language-json">{ toJson(props.Content) }</code></pre>
                    }
                }
                @layout.Sidebar() {
                    <h2>Children</h2>
                    @RefList(props.ResolvedRef, BuildRefTree(props.ChildRefs))
                }
            }
    }
}

func toJson(content any) string {
	j, err := json.MarshalIndent(content, "", "  ")
	if err != nil {
		return ""
	}
	return string(j)
}

templ RefList(prefix string, refs RefMap) {
    <ul class="list-style-circle">
    for _, key := range refs.OrderedKeys() {
        <li>
            <a href={ fmt.Sprintf("/ref/%s", key) }>{ strings.TrimPrefix(key, prefix) }</a>
            @RefList(key, refs[key])
        </li>
    }
    </ul>
}
